'use strict'

var _extends =
  Object.assign ||
  function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i]
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key]
        }
      }
    }
    return target
  }

function _objectWithoutProperties(obj, keys) {
  var target = {}
  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue
    target[i] = obj[i]
  }
  return target
}

function _asyncToGenerator(fn) {
  return function() {
    var gen = fn.apply(this, arguments)
    return new Promise(function(resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg)
          var value = info.value
        } catch (error) {
          reject(error)
          return
        }
        if (info.done) {
          resolve(value)
        } else {
          return Promise.resolve(value).then(
            function(value) {
              step('next', value)
            },
            function(err) {
              step('throw', err)
            }
          )
        }
      }
      return step('next')
    })
  }
}

const debug = require('debug')('Clair.Client')
const assert = require('assert-plus')
const rp = require('request-promise-native')
const DockerRegistry = require('./docker-registry')
const AppError = require('./error')

const ClairError = class extends AppError {}

class Clair {
  constructor({ clairAddress, headers = {}, dockerUsername = null, dockerPassword = null, dockerInsecure = false }) {
    assert.string(clairAddress, 'clairAddress')

    this.clairAddress = clairAddress
    this.dockerUsername = dockerUsername
    this.dockerPassword = dockerPassword
    this.dockerInsecure = dockerInsecure

    this.userHeaders = headers
    this.rp = rp.defaults({
      baseUrl: this.clairAddress,
      json: true
    })
  }

  static get apiV1() {
    return {
      uploadLayer: '/v1/layers',
      getLayer: '/v1/layers'
    }
  }

  // use the authorization from the docker registry client because it
  // already knows how to create the unauthenticated bearer token
  getHeaders(registry) {
    var _this = this

    return _asyncToGenerator(function*() {
      const ua = 'node-clair-docker/1.0.0'

      return _extends({}, _this.userHeaders, { 'User-Agent': ua, authorization: yield registry.getAuthorization() })
    })()
  }

  prepareLayers({ registry, layers }) {
    var _this2 = this

    return _asyncToGenerator(function*() {
      const Headers = yield _this2.getHeaders(registry)
      return layers
        .map(function(layer, index, array) {
          return _extends({}, layer, { ParentName: index === 0 ? '' : array[index - 1].Name })
        })
        .map(function(layer) {
          return { Layer: _extends({}, layer, { Headers, Format: 'Docker' }) }
        })
    })()
  }

  uploadLayers(image, layers) {
    var _this3 = this

    return _asyncToGenerator(function*() {
      const method = 'POST'
      const uri = Clair.apiV1.uploadLayer

      // layer analysis must be done sequentially, in order of layers,
      // one at a time, as per the docs:
      //
      // https://coreos.com/clair/docs/latest/api_v1.html#post-layers
      var _iteratorNormalCompletion = true
      var _didIteratorError = false
      var _iteratorError = undefined

      try {
        for (var _iterator = layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          const body = _step.value
          // eslint-disable-line no-restricted-syntax
          try {
            debug('%o: uploading layer...', body.Layer.Name)
            debug('%j', body)
            // console.log(body)
            // eslint-disable-next-line no-await-in-loop
            const ret = yield _this3.rp({ method, uri, body })
            debug('%o: upload success', body.Layer.Name)
            debug('%j', ret)
          } catch (err) {
            debug(err)
            throw new ClairError(`error uploading layers for image '${image}': ${err.message}`)
          }
        }
      } catch (err) {
        _didIteratorError = true
        _iteratorError = err
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return()
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError
          }
        }
      }
    })()
  }

  getAnalysis(image, preparedLayers) {
    var _this4 = this

    return _asyncToGenerator(function*() {
      const qs = 'features=true&vulnerabilities=true'
      const last = preparedLayers[preparedLayers.length - 1]
      const uri = `${Clair.apiV1.getLayer}/${last.Layer.Name}?${qs}`
      try {
        debug('getting analysis for %o', image)
        const ret = yield _this4.rp({ uri })
        const vulnerabilities = ret.Layer.Features.reduce(function(acc, feature) {
          if (feature.Vulnerabilities) {
            acc.push(feature)
          }

          return acc
        }, [])

        return _extends({}, ret, { vulnerabilities })
      } catch (err) {
        throw new ClairError(`error retrieving analysis for image '${image}': ${err.message}`)
      }
    })()
  }

  analyze({ image, resolveWithFullResponse = false, registry: argRegistry }) {
    var _this5 = this

    return _asyncToGenerator(function*() {
      assert.string(image, 'image')
      assert.bool(resolveWithFullResponse)

      debug('analyzing image %o', image)
      const dockerUsername = _this5.dockerUsername,
        dockerPassword = _this5.dockerPassword,
        dockerInsecure = _this5.dockerInsecure
      console.log(`insecure: `)

      const registry = argRegistry || new DockerRegistry(image, dockerUsername, dockerPassword, dockerInsecure)
      const layers = yield registry.getLayers()
      const preparedLayers = yield _this5.prepareLayers({ registry, layers })

      yield _this5.uploadLayers(image, preparedLayers)

      var _ref = yield _this5.getAnalysis(image, preparedLayers)

      const vulnerabilities = _ref.vulnerabilities,
        fullResponse = _objectWithoutProperties(_ref, ['vulnerabilities'])

      if (resolveWithFullResponse) {
        return fullResponse
      }

      return {
        isVulnerable: !!vulnerabilities.length,
        image,
        layers,
        vulnerabilities
      }
    })()
  }
}

module.exports = Clair
